import { RequestClient, IntegrationError } from '@segment/actions-core'
import { HubSpotError } from '../errors'
import { HUBSPOT_BASE_URL } from '../properties'
import { SUPPORTED_HUBSPOT_OBJECT_TYPES } from './constants'
import type { Payload } from './generated-types'
import { DynamicFieldResponse } from '@segment/actions-core'



interface ReadPropertiesResultItem {
    name: string,
    type: string
    fieldType: string,
    hasUniqueValue: boolean
}

interface PayloadPropertyItem {
    name: string;
    type: string | number | boolean | null
}

enum AssociationCategory {
    HUBSPOT_DEFINED = 'HUBSPOT_DEFINED',
    USER_DEFINED = 'USER_DEFINED',
    INTEGRATOR_DEFINED = 'INTEGRATOR_DEFINED'
}

interface BatchObjReadReqBody {
    idProperty: string
    properties: string[]
    inputs: Array<{ id: string }>
}

interface BatchObjUpsertReqBody {
    inputs: Array<{
        idProperty: string
        id: string
        properties: Record<string, string>
    }>
}
interface BatchObjAddReqBody {
    inputs: Array<{
        idProperty: string
        properties: Record<string, string>
    }>
}

interface BatchObjResponse {
    status: string
    results: Array<{
        id: string
        properties: Record<string, string | null>
    }>
}

interface AssociationType {
    associationCategory: AssociationCategory
    associationTypeId: string
}

interface BatchAssociationsRequestBody {
    inputs: {
        types: AssociationType[];
        from: {
            id: string;
        };
        to: {
            id: string;
        };
    }[];
}

export class HubspotClient {
    request: RequestClient
    syncMode: string | null

    constructor(request: RequestClient, syncMode?: string) {
        this.request = request
        this.syncMode = syncMode ?? null
    }

    async dynamicReadIdFields(objectType: string) {

        interface ResultItem {
            label: string
            name: string
            hasUniqueValue: boolean
        }
        
        interface ResponseType {
            data: {
                results: ResultItem[]
            }
        }

        try {
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}`, {
                method: 'GET',
                skipResponseCloning: true
            })
            
            return {
                choices: [
                    {
                        label: 'Hubspot Record ID (updates only)',
                        value: 'hs_object_id'
                    },
                    // hs_unique_creation_key is a unique identifier that is automatically generated by HubSpot. It is readonly so should not be included in the dynamic list
                    ...response.data.results
                    .filter((field: ResultItem) => field.hasUniqueValue && field.name != 'hs_unique_creation_key')
                    .map((field: ResultItem) => {
                        return {
                        label: field.label,
                        value: field.name
                        }
                    })
                ]
            }
        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error: getPropertyGroups',
                    code: (err as HubSpotError)?.response?.status + '' ?? '500'
                }
            }
        }
    }

    async dynamicReadPropertyGroups(objectType: string): Promise<DynamicFieldResponse> {
        interface ResultItem {
            label: string
            name: string
            displayOrder: number, 
            archived: boolean
        }
        
        interface ResponseType {
            data: {
                results: ResultItem[]
            }
        }

        try {
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}/groups`, {
                method: 'GET',
                skipResponseCloning: true
            })

            return { choices: response.data.results
                .filter(result => !result.archived)
                .map((result) => ({
                label: result.label,
                value: result.name
            })) }

        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error: getPropertyGroups',
                    code: (err as HubSpotError)?.response?.status + '' ?? '500'
                }
            }
        }
    }

    async dynamicReadAssociationLabels(fromObjectType: string, toObjectType: string): Promise<DynamicFieldResponse> {
        interface ResultItem {
            category: AssociationCategory
            typeId: number
            label: string
        }
        interface ResponseType {
            data: {
                results: ResultItem[]
            }
        }
        
        try {
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v4/associations/${fromObjectType}/${toObjectType}/labels`, {
                method: 'GET',
                skipResponseCloning: true
            })

            return {
                choices: response?.data?.results?.map((res) => ({
                    label: !res.label ? `${fromObjectType} to ${toObjectType} (Type ${res.typeId})` : `${fromObjectType} to ${toObjectType} ${res.label}`,
                    value: `${res.category}:${res.typeId}`
                }))
            }
        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
                    code: (err as HubSpotError)?.response?.data?.category ?? 'Unknown code'
                }
            }
        }
    }

    async dynamicReadObjectTypes(): Promise<DynamicFieldResponse> {
        interface ResultItem {
            labels: { singular: string; plural: string }
            fullyQualifiedName: string
        }
        
        interface ResponseType {
            data: {
                results: ResultItem[]
            }
        }
        
        const defaultChoices = SUPPORTED_HUBSPOT_OBJECT_TYPES
       
        try {
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/schemas?archived=false`, {
                method: 'GET',
                skipResponseCloning: true
            })
            const choices = response.data.results
                .map((schema) => ({
                    label: `${schema.labels.plural} (Custom)`,
                    value: schema.fullyQualifiedName
                }))
            return {
                choices: [...choices, ...defaultChoices]
            }
        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
                    code: (err as HubSpotError)?.response?.status + '' ?? '500'
                }
            }
        }
    }

    getAssociationType(associationLabel: string): AssociationType {
        const [associationCategory, associationTypeId] = associationLabel.split(':');
        return { associationCategory, associationTypeId } as AssociationType
    }

    async batchAssociationsRequest(body: BatchAssociationsRequestBody, objectType: string, toObjectType: string){
        if(body.inputs.length === 0){
            return null
        }
        
        return this.request<BatchReadResponse>(`${HUBSPOT_BASE_URL}/crm/v4/associations/${objectType}/${toObjectType}/batch/create`, {
            method: 'POST',
            json: body
        })
    }

    async ensureAssociations(payloads: Payload[]) {
        const [{objectType, toObjectType, associationLabel}] = payloads
        
        if(!objectType || !toObjectType || !associationLabel){
            throw new IntegrationError('Missing required Association fields. Associations require "To Object Type", "To ID Field Name" and "Association Label" fields to be set.','REQUIRED_ASSOCIATION_FIELDS_MISSING',400)
        }
        
        const {associationCategory, associationTypeId} = this.getAssociationType(associationLabel)

        const requestBody: BatchAssociationsRequestBody = {
            inputs: payloads.filter(p => p.recordID && p.toRecordID).map(p => { 
                return {
                    types: [
                        {
                            associationCategory,
                            associationTypeId
                        }
                    ],
                    from: {
                        id: p.recordID as string
                    },
                    to: {
                        id: p.toRecordID as string
                    }
                }
            }) ?? []
        }

        return this.batchAssociationsRequest(requestBody, objectType, toObjectType)
    }

    async readProperties(objectType: string): Promise<ReadPropertiesResultItem[]> {
        interface ResponseType {
            data: {
                status: string
                results: ReadPropertiesResultItem[]
            } 
        }

        try{
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}`, {
                method: 'GET',
                skipResponseCloning: true
            })

            return response.data.results
                .map((item: ReadPropertiesResultItem) => {
                    return {
                        name: item.name,
                        type: item.type,
                        fieldType: item.fieldType,
                        hasUniqueValue: item.hasUniqueValue
                    }
                }) as ReadPropertiesResultItem[]

        } catch(err) {
            throw new IntegrationError(`readProperties() failed: ${(err as HubSpotError)?.response?.data?.message ?? 'Unknown error: readProperties() failed'}`, 'HUBSPOT_READ_PROPERTIES_FAILED', 400)
        }
    }

    findUniquePayloadsProps(payloads: Payload[]): PayloadPropertyItem[] {        
        return Object.values(
            payloads.reduce((acc, payload) => {
                if(payload.properties) {
                    Object.keys(payload.properties).forEach(propName => {
                        if(payload.properties) { // to keep linter happy
                            acc[propName] = { 
                                name: propName, 
                                type: typeof payload.properties[propName]
                            }
                        }
                    })
                }
                return acc
            }, 
            {} as { [name: string]: PayloadPropertyItem })
        )
    }

    createListPropsToCreate(uniquePayloadProperties: PayloadPropertyItem[], hubspotProperties: ReadPropertiesResultItem[]): PayloadPropertyItem[]{
        return uniquePayloadProperties.filter(prop => !hubspotProperties.find(p => p.name === prop.name))
    }

    async ensureProperties(objectType: string, propertyGroup: string,  properties: PayloadPropertyItem[]){
  
        interface RequestBody {
            inputs: Array<{
                label: string,
                type: 'string' | 'number' | 'enumeration',
                groupName: string,
                name: string,
                fieldType: 'text' | 'number' | 'booleancheckbox',
                options?: Array<{
                    label: string,
                    value: string,
                    hidden: boolean,
                    description: string,
                    displayOrder: 1 | 2
                }>
            }> 
        }

        const json = { 
            inputs: properties.map(prop => {
                switch(prop.type){
                    case 'string':
                        return {
                            name: prop.name,
                            label: prop.name,
                            groupName: propertyGroup,
                            type: "string",
                            fieldType: "text"
                        }
                    case 'number':
                        return {
                            name: prop.name,
                            label: prop.name,
                            groupName: propertyGroup,
                            type: "number",
                            fieldType: "number"
                        }    
                    case 'boolean':
                        return {
                            name: prop.name,
                            label: prop.name,
                            groupName: propertyGroup,
                            type: "enumeration",
                            fieldType: 'booleancheckbox', 
                            options: [
                                {
                                    label: "true",
                                    value: "true",
                                    hidden: false,
                                    description: "True",
                                    displayOrder: 1
                                },
                                {
                                    label: "false",
                                    value: "false",
                                    hidden: false,
                                    description: "False",
                                    displayOrder: 2
                                }
                            ]
                        }
                }
            })
        } as RequestBody
        
        await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}/batch/create`, {
            method: 'POST',
            skipResponseCloning: true,
            json
        })
    }

    async batchObjectRequest(
        action: 'upsert' | 'create' | 'update' |'read', 
        objectType: string,
        data: BatchObjReadReqBody | BatchObjUpsertReqBody | BatchObjAddReqBody
    ) {   
        return this.request<BatchObjResponse>(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/batch/${action}`, {
            method: 'POST',
            json: data
        });
    }

    async enrichPayloadsWithHubspotIds(payloads: Payload[], fromObjectType: string, fromIdFieldName: string) {    
        
        const response = await this.batchObjectRequest('read', fromObjectType, {
            properties: [fromIdFieldName],
            idProperty: fromIdFieldName,
            inputs: payloads.map(payload => { 
                return {id: payload.object_details.from_id_field_value}
            })             
        } as BatchObjReadReqBody)

        response?.data.results.forEach(result => {
            payloads
                .filter(payload => payload.object_details.from_id_field_value == result.properties[fromIdFieldName] as string)
                .forEach(payload => payload.object_details.exists_on_hubspot = true )
        })

        return payloads
    }

    async ensureFromObjects(payloads: Payload[], syncMode: 'upsert' | 'add' | 'update') {
        const { 
            object_details: { 
                from_object_type: fromObjectType, 
                from_id_field_name: fromIdFieldName 
            } 
        } = payloads[0]

        switch(syncMode){
            case 'upsert': {
                const body: BatchObjUpsertReqBody = {
                    inputs: []
                }
    
                payloads.forEach(({ object_details: { from_id_field_value }, properties }) => {
                    body.inputs.push({
                      idProperty: fromIdFieldName,
                      id: from_id_field_value,
                      properties: properties 
                    })
                })
    
                return await this.batchObjectRequest(syncMode, fromObjectType, body)
            }

            case 'update': {
                const body: BatchObjUpsertReqBody = {
                    inputs: []
                }

                const enrichedPayloads = await this.enrichPayloadsWithHubspotIds(payloads, fromObjectType, fromIdFieldName)
            
                // Only update objects that have a hs_object_id. We still use the from_id_field_value to identify the object
                enrichedPayloads
                .filter(({ object_details }) => object_details.exists_on_hubspot)
                .forEach(({ object_details: { from_id_field_value }, properties }) => {
                    body.inputs.push({
                        idProperty: fromIdFieldName,
                        id: from_id_field_value,
                        properties
                    })
                }) 

                return await this.batchObjectRequest(syncMode, fromObjectType, body)
            }

            case 'add': {
                const body: BatchObjAddReqBody = {
                    inputs: []
                }
                
                const enrichedPayloads = await this.enrichPayloadsWithHubspotIds(payloads, fromObjectType, fromIdFieldName)
        
                // Only update objects that don't have a hs_object_id. We still use the from_id_field_value to create the object
                enrichedPayloads
                .filter(({ object_details }) => !object_details.exists_on_hubspot)
                .forEach(({ object_details: { from_id_field_value }, properties }) => {
                    body.inputs.push({
                        idProperty: fromIdFieldName,
                        properties: { ...properties, [fromIdFieldName]: from_id_field_value },
                    })
                }) 

                return await this.batchObjectRequest('create', fromObjectType, body)
            }
        }
    }
}
