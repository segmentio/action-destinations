import { RequestClient, IntegrationError } from '@segment/actions-core'
import { HubSpotError } from '../errors'
import { HUBSPOT_BASE_URL } from '../properties'
import { SUPPORTED_HUBSPOT_OBJECT_TYPES } from './constants'
import type { Payload } from './generated-types'
import { DynamicFieldResponse } from '@segment/actions-core'



interface ReadPropertiesResultItem {
    name: string,
    type: string
    fieldType: string,
    hasUniqueValue: boolean
}

interface PayloadPropertyItem {
    name: string;
    type: string | number | boolean | null
}

enum AssociationCategory {
    HUBSPOT_DEFINED = 'HUBSPOT_DEFINED',
    USER_DEFINED = 'USER_DEFINED',
    INTEGRATOR_DEFINED = 'INTEGRATOR_DEFINED'
}

interface BatchReadRequestBody {
    properties: string[]
    idProperty: string
    inputs: Array<{ id: string }>
}

interface BatchReadResponse {
    status: string
    results: BatchReadResponseItem[]
}

interface BatchReadResponseItem {
    id: string
    properties: Record<string, string | null>
}

interface BatchRequestBody {
    inputs: BatchRequestBodyItem[];
}
interface BatchRequestBodyItem {
    properties: {
        [key: string]: string | number | boolean | undefined;
    };
    id?: string;
}

interface AssociationType {
    associationCategory: AssociationCategory
    associationTypeId: string
}

interface BatchAssociationsRequestBody {
    inputs: {
        types: AssociationType[];
        from: {
            id: string;
        };
        to: {
            id: string;
        };
    }[];
}

export class HubspotClient {
    request: RequestClient
    syncMode: string | null

    constructor(request: RequestClient, syncMode?: string) {
        this.request = request
        this.syncMode = syncMode ?? null
    }

    async dynamicReadIdFields(objectType: string) {

        interface ResultItem {
            label: string
            name: string
            hasUniqueValue: boolean
        }
        
        interface ResponseType {
            data: {
                results: ResultItem[]
            }
        }

        try {
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}`, {
                method: 'GET',
                skipResponseCloning: true
            })
            
            return {
                choices: [
                    {
                        label: 'Hubspot Record ID (updates only)',
                        value: 'hs_object_id'
                    },
                    // hs_unique_creation_key is a unique identifier that is automatically generated by HubSpot. It is readonly so should not be included in the dynamic list
                    ...response.data.results
                    .filter((field: ResultItem) => field.hasUniqueValue && field.name != 'hs_unique_creation_key')
                    .map((field: ResultItem) => {
                        return {
                        label: field.label,
                        value: field.name
                        }
                    })
                ]
            }
        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error: getPropertyGroups',
                    code: (err as HubSpotError)?.response?.status + '' ?? '500'
                }
            }
        }
    }

    async dynamicReadPropertyGroups(objectType: string): Promise<DynamicFieldResponse> {
        interface ResultItem {
            label: string
            name: string
            displayOrder: number, 
            archived: boolean
        }
        
        interface ResponseType {
            data: {
                results: ResultItem[]
            }
        }

        try {
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}/groups`, {
                method: 'GET',
                skipResponseCloning: true
            })

            return { choices: response.data.results
                .filter(result => !result.archived)
                .map((result) => ({
                label: result.label,
                value: result.name
            })) }

        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error: getPropertyGroups',
                    code: (err as HubSpotError)?.response?.status + '' ?? '500'
                }
            }
        }
    }

    async dynamicReadAssociationLabels(fromObjectType: string, toObjectType: string): Promise<DynamicFieldResponse> {
        interface ResultItem {
            category: AssociationCategory
            typeId: number
            label: string
        }
        interface ResponseType {
            data: {
                results: ResultItem[]
            }
        }
        
        try {
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v4/associations/${fromObjectType}/${toObjectType}/labels`, {
                method: 'GET',
                skipResponseCloning: true
            })

            return {
                choices: response?.data?.results?.map((res) => ({
                    label: !res.label ? `${fromObjectType} to ${toObjectType} (Type ${res.typeId})` : `${fromObjectType} to ${toObjectType} ${res.label}`,
                    value: `${res.category}:${res.typeId}`
                }))
            }
        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
                    code: (err as HubSpotError)?.response?.data?.category ?? 'Unknown code'
                }
            }
        }
    }

    async dynamicReadObjectTypes(): Promise<DynamicFieldResponse> {
        interface ResultItem {
            labels: { singular: string; plural: string }
            fullyQualifiedName: string
        }
        
        interface ResponseType {
            data: {
                results: ResultItem[]
            }
        }
        
        const defaultChoices = SUPPORTED_HUBSPOT_OBJECT_TYPES
       
        try {
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/schemas?archived=false`, {
                method: 'GET',
                skipResponseCloning: true
            })
            const choices = response.data.results
                .map((schema) => ({
                    label: `${schema.labels.plural} (Custom)`,
                    value: schema.fullyQualifiedName
                }))
            return {
                choices: [...choices, ...defaultChoices]
            }
        } catch (err) {
            return {
                choices: [],
                error: {
                    message: (err as HubSpotError)?.response?.data?.message ?? 'Unknown error',
                    code: (err as HubSpotError)?.response?.status + '' ?? '500'
                }
            }
        }
    }

    getAssociationType(associationLabel: string): AssociationType {
        const [associationCategory, associationTypeId] = associationLabel.split(':');
        return { associationCategory, associationTypeId } as AssociationType
    }

    async batchObjectRequest(
        action: 'update' | 'add' | 'read', 
        objectType: string,
        data: BatchReadRequestBody | BatchRequestBody
    ) {    
        if(data.inputs.length === 0){
            return null
        }

        return this.request<BatchReadResponse>(`${HUBSPOT_BASE_URL}/crm/v3/objects/${objectType}/batch/${action}`, {
            method: 'POST',
            json: data
        });
    }

    async batchAssociationsRequest(body: BatchAssociationsRequestBody, objectType: string, toObjectType: string){
        if(body.inputs.length === 0){
            return null
        }
        
        return this.request<BatchReadResponse>(`${HUBSPOT_BASE_URL}/crm/v4/associations/${objectType}/${toObjectType}/batch/create`, {
            method: 'POST',
            json: body
        })
    }

    async ensureAssociations(payloads: Payload[]) {
        const [{objectType, toObjectType, associationLabel}] = payloads
        
        if(!objectType || !toObjectType || !associationLabel){
            throw new IntegrationError('Missing required Association fields. Associations require "To Object Type", "To ID Field Name" and "Association Label" fields to be set.','REQUIRED_ASSOCIATION_FIELDS_MISSING',400)
        }
        
        const {associationCategory, associationTypeId} = this.getAssociationType(associationLabel)

        const requestBody: BatchAssociationsRequestBody = {
            inputs: payloads.filter(p => p.recordID && p.toRecordID).map(p => { 
                return {
                    types: [
                        {
                            associationCategory,
                            associationTypeId
                        }
                    ],
                    from: {
                        id: p.recordID as string
                    },
                    to: {
                        id: p.toRecordID as string
                    }
                }
            }) ?? []
        }

        return this.batchAssociationsRequest(requestBody, objectType, toObjectType)
    }

    async readProperties(objectType: string): Promise<ReadPropertiesResultItem[]> {
        interface ResponseType {
            data: {
                status: string
                results: ReadPropertiesResultItem[]
            } 
        }

        try{
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}`, {
                method: 'GET',
                skipResponseCloning: true
            })

            return response.data.results
                .map((item: ReadPropertiesResultItem) => {
                    return {
                        name: item.name,
                        type: item.type,
                        fieldType: item.fieldType,
                        hasUniqueValue: item.hasUniqueValue
                    }
                }) as ReadPropertiesResultItem[]

        } catch(err) {
            throw new IntegrationError(`readProperties() failed: ${(err as HubSpotError)?.response?.data?.message ?? 'Unknown error: readProperties() failed'}`, 'HUBSPOT_READ_PROPERTIES_FAILED', 400)
        }
    }

    findUniquePropertiesFromPayloads(payloads: Payload[]): PayloadPropertyItem[] {        

        return Object.values(payloads.reduce((acc, payload) => {
            for (const prop in payload.properties) {
              if (payload.properties[prop]) {
                acc[prop] = { name: prop, type: typeof payload.properties[prop] };
              }
            }
            return acc;
        }, {} as { [name: string]: PayloadPropertyItem }))

    }

    async createProperties(objectType: string, properties: PayloadPropertyItem[]){
        
        
        interface ResponseType {
            data: {
                status: string
                results: CreatePropertiesResultItem[]
            } 
        }

        try{
            const response: ResponseType = await this.request(`${HUBSPOT_BASE_URL}/crm/v3/properties/${objectType}/batch/create`, {
                method: 'GET',
                skipResponseCloning: true
            })

            return response.data.results
                .map((item: ReadPropertiesResultItem) => {
                    return {
                        name: item.name,
                        type: item.type,
                        fieldType: item.fieldType,
                        hasUniqueValue: item.hasUniqueValue
                    }
                }) as ReadPropertiesResultItem[]

        } catch(err) {
            throw new IntegrationError(`readProperties() failed: ${(err as HubSpotError)?.response?.data?.message ?? 'Unknown error: readProperties() failed'}`, 'HUBSPOT_READ_PROPERTIES_FAILED', 400)
        }
        
        https://api.hubapi.com/crm/v3/properties//batch/create
    }

    async ensureProperties(payloads: Payload[]) {   

        const missingProps = uniquePayloadProps.filter(prop => !propsFromHubspot.data.results.find((p: Property) => p.name === prop.name))

        console.log('missingProperties', missingProps)

        if(missingProps.length > 0){
            
            // const createPropsRequestBody = {
            //     inputs: [
            //         {
            //             "hidden": false,
            //             "description": "string",
            //             "label": "My Contact Property",
            //             "type": "enumeration",
            //             "formField": false,
            //             "groupName": "contactinformation",

            //             "referencedObjectType": "string",
            //             "name": "string",
            //             "options": [
            //               {
            //                 "label": "Option A",
            //                 "value": "A",
            //                 "hidden": false,
            //                 "description": "Choice number one",
            //                 "displayOrder": 1
            //               },
            //               {
            //                 "label": "Option B",
            //                 "value": "B",
            //                 "hidden": false,
            //                 "description": "Choice number two",
            //                 "displayOrder": 2
            //               }
            //             ],
            //             "calculationFormula": "string",
            //             "hasUniqueValue": false,
            //             "fieldType": "select",
            //             "externalOptions": true
            //           }
            //     ]
            // }

            // const propsFromHubspot = await this.request<PropertyReadResponse>(`${HUBSPOT_BASE_URL}/crm/v3/properties/${toObjectType}/batch/create`, {
            //     method: 'GET',
            //     skipResponseCloning: true
            // })

        }


    }

    // async ensureFromObjects(payloads: Payload[]) {

    //     const { 
    //         object_details: { 
    //             from_object_type: fromObjectType, 
    //             from_id_field_name: fromIdFieldName 
    //         } 
    //     } = payloads[0]

    //     const readResponse = await this.batchObjectRequest('read', fromObjectType, {
    //         properties: [fromIdFieldName],
    //         idProperty: fromIdFieldName,
    //         inputs: payloads.map(p => { return {id: p.object_details.from_id_field_value}})             
    //     } as BatchReadRequestBody)
       
    //     readResponse?.data.results.forEach(result => {
    //         payloads
    //             .filter(payload => payload.object_details.from_id_field_value == result.properties[fromIdFieldName] as string)
    //             .forEach(payload => payload.object_details.from_hs_object_id = result.id )
    //     })

    //     const updateRequestBody: BatchRequestBody = {inputs:[]}
    //     const createRequestBody: BatchRequestBody = {inputs:[]}

    //     payloads.forEach((payload) => {

    //         const itemPayload: { id?: string | undefined; properties: { [key: string]: string | number | boolean | undefined } } = {
    //             id: payload.object_details.from_id_field_name ?? undefined,
    //             properties: {
    //                 ...payload.properties,
    //                 [fromIdFieldName]: payload.object_details.from_id_field_value
    //             } as BatchRequestBodyItem['properties']
    //         } as BatchRequestBodyItem

    //         if(['update', 'upsert'].includes(this.syncMode) && itemPayload.id){
    //             updateRequestBody.inputs.push(itemPayload)
    //         }

    //         if(['add', 'upsert'].includes(this.syncMode) && !itemPayload.id){
    //             createRequestBody.inputs.push(itemPayload)
    //         }
    //     })
        
    //     return Promise.all([
    //         this.batchObjectRequest('update', fromObjectType, updateRequestBody),
    //         this.batchObjectRequest('add', fromObjectType, createRequestBody)
    //     ].filter(request => request !== null))
    //     .then(writeRequests => writeRequests.length > 0 ? writeRequests : null);
    // }

}
